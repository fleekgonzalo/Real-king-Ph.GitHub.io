---
tag: è“æ¡¥æ¯
categories: misc
title: 2022è“æ¡¥æ¯Aç»„éƒ¨åˆ†ä¸ªäººé¢˜è§£
mermaid: true
mathjax: true
---



[æŸ¥çœ‹é¢˜ç›®]({{site.url}}/assets/others/ç¬¬åä¸‰å±Šè“æ¡¥æ¯å¤§èµ›è½¯ä»¶èµ›çœèµ›_CA.pdf){:.button.button--outline-secondary.button--pill}

## A - è£çº¸åˆ€

æ²¡å•¥å¥½è¯´çš„ $x\times y - 1 + 4$

## B - ç­é¼ å…ˆé”‹

ç›´æ¥çˆ†ç´¢å³å¯ã€‚`å…ˆåæ‰‹é¡ºåºæ²¡æ˜ç™½`{:.warning}

{% highlight cpp liones %}
#include <iostream>

using namespace std;

//--- å¡«å…¥åˆå§‹çŠ¶å†µ ---
int board[2][4] = {
    {0, 1, 1, 0},
    {0, 0, 0, 0},
};

bool dfs(int now = 0) {
   bool ff = false;
   for (int i = 0; i < 2; i++) {
      for (int j = 0; j < 4; j++) {
         if (board[i][j] == 0) {
            ff = true;
            board[i][j] = 1;
            int f = dfs(now ^ 1);
            board[i][j] = 0;
            if (!f) return true;
         }
      }
   }

   if (!ff) return true;

   for (int i = 0; i < 2; i++) {
      for (int j = 0; j < 3; j++) {
         if (board[i][j] == 0 && board[i][j + 1] == 0) {
            board[i][j] = board[i][j + 1] = 1;
            int f = dfs(now ^ 1);
            board[i][j] = board[i][j + 1] = 0;
            if (!f) return true;
         }
      }
   }

   return false;
}

int main() {
   cout << !dfs() << '\n';
   return 0;
}
{% endhighlight %}

## C - æ±‚å’Œ

æˆ‘ä»¬å‘ç°ç­”æ¡ˆæ˜¯ $\sum\limits_{i=1}^na_i \times\sum\limits_{j=i+1}^n a_j$ é‚£ä¹ˆæ·»åŠ ä¸€ä¸ªå‰ç¼€å’Œå³å¯

{% highlight cpp liones %}
#include <iostream>

using namespace std;

long long S[200010];

int main() {
   int n;
   scanf("%d", &n);

   for (int i = 1; i <= n; i++) {
      scanf("%lld", &S[i]);
      S[i] += S[i - 1];
   }

   long long ans = 0;

   for (int i = 1; i <= n; i++) {
      ans += (S[i] - S[i - 1]) * (S[n] - S[i]);
   }

   cout << ans << '\n';

   return 0;
}
{% endhighlight %}

## D - é€‰æ•°å¼‚æˆ–

ä¸€ä¸ªè£¸çš„[è«é˜Ÿ]({{site.url}}/algorithm/2022/03/29/D-querrys.html)ã€‚ä¸è¿‡æˆ‘ä»¬éœ€è¦ç‰¹åˆ¤ `0` å¸¦æ¥çš„ç­”æ¡ˆã€‚

{% highlight cpp liones %}
#include <algorithm>
#include <iostream>

using namespace std;

int cnt[2000010];
int a[100010];
int n, m, x;
int prt;

struct Que {
   int l, r, id;
   bool operator<(const Que& B) const {
      if (l / prt == B.l / prt) return r < B.r;
      return l / prt < B.l / prt;
   };
} q[100010];

bool ans[100010];

void find() {
   int l = 0, r = 1000;
   while (l <= r) {
      int m = (l + r) >> 1;
      if (m * m >= n) {
         prt = m;
         r = m - 1;
      } else {
         l = m + 1;
      }
   }
}

int l = 1, r = 0;

int que = 0;

void add(int i) {
   if (cnt[a[i]]) que += cnt[a[i]];
   int numb = a[i] ^ x;
   cnt[numb]++;
}

void del(int i) {
   if (cnt[a[i]]) {
      if (x == 0)
         que -= cnt[a[i]] - 1;
      else
         que -= cnt[a[i]];
   }
   int numb = a[i] ^ x;
   cnt[numb]--;
}

int main() {
   scanf("%d%d%d", &n, &m, &x);
   // cin >> n >> m >> x;
   find();
   for (int i = 1; i <= n; i++) {
      scanf("%d", &a[i]);
   }
   for (int i = 0; i < m; i++) {
      scanf("%d%d", &q[i].l, &q[i].r);
      q[i].id = i;
   }
   sort(q, q + m);

   for (int i = 0; i < m; i++) {
      int ql = q[i].l;
      int qr = q[i].r;
      while (r < qr) add(++r);
      while (l > ql) add(--l);
      while (r > qr) del(r--);
      while (l < ql) del(l++);
      ans[ q[i].id] = que;
   }

   for (int i = 0; i < m; i++) {
      if (ans[i])
         puts("yes");
      else
         puts("no");
   }
}
{% endhighlight %}

è¿˜æœ‰åˆ«çš„åšæ³•,å‚è€ƒã€‚ç¼–è¯‘æ—¶è®°å¾—åŠ å‚æ•° `-std=c++17`ã€‚

å¦‚æœä½ å†™ st çš„è¯å¯ä»¥å‚è€ƒä¸‹é¢çš„ä»£ç ~~æ¯”çº¿æ®µæ ‘ç®€æ´ä¸€ä¸‡å€~~ã€‚

```cpp
int val[N]        // --> è¡¨ç¤ºæœ€å°çš„ R
int fval[N][20]   // --> ST è¡¨ã€‚

for (int i = 1 ; i <= n ; i ++) fval[i][0] = val[N];

// è¡¨ç¤º åŒºé—´ [i , i + 2^j - 1] åŒºé—´çš„æœ€å°å€¼ã€‚

// func init();
void init() {
   for (int j = 0 ; j < 19 ; j ++) {
      for (int i = 0 ; i <= n ; i ++) {
         fval[i][j + 1] = min(fval[i][j] , fval[i + (1 << j)][j]);
      }
   }
}

// func querry(int l,int r);
int querry(int l,int r) {
   int res = 1e9;
   int now = l;
   for (int i = 19 ; i >= 0 ; i --) {
      int nxt = now + (1 << i);
      if(nxt - 1 <= r) {
         res = min(res , fval[now][i]);
         now = nxt;
      }
   }
   return res;
}

```

çº¿æ®µæ ‘å°±å¦‚ä¸‹ã€‚

{% highlight cpp liones %}
#include <iostream>
#include <vector>

using namespace std;

struct SEG_Tree {
   vector<int> mn;
   vector<pair<int, int>> Range;
   SEG_Tree(int n) {
      int sz = 1;
      while (sz < n) sz *= 2;
      sz *= 2;
      mn.assign(sz, n + 1);
      Range.assign(sz, {});
      build(1, n);
   }

   int Lson(int x) { return x * 2 + 1; }
   int Rson(int x) { return x * 2 + 2; }

   void build(int l, int r, int p = 0) {
      Range[p] = {l, r};
      if (l == r) return;
      int m = (l + r) >> 1;
      build(l, m, Lson(p));
      build(m + 1, r, Rson(p));
   }

   void set(int x, int v, int p = 0) {
      auto [l, r] = Range[p];
      if (l == r) {
         mn[p] = v;
         return;
      }
      int m = (l + r) >> 1;
      if (x <= m) set(x, v, Lson(p));
      if (x > m) set(x, v, Rson(p));
      mn[p] = min(mn[Lson(p)], mn[Rson(p)]);
   }

   int querry(int x, int y, int p = 0) {
      auto [l, r] = Range[p];
      if (x <= l && r <= y) {
         return mn[p];
      }
      int res = 1e9;
      int m = (l + r) >> 1;
      if (x <= m) res = min(res, querry(x, y, Lson(p)));
      if (y > m) res = min(res, querry(x, y, Rson(p)));
      return res;
   }
};

int main() {
   ios::sync_with_stdio(false);
   cin.tie(0);
   int n, m, x;
   cin >> n >> m >> x;
   vector<int> a(n + 1);
   for (int i = 1; i <= n; i++) cin >> a[i];

   vector<int> cnt(1 << 20, n + 1);

   SEG_Tree st(n);

   for (int i = n; i >= 1; i--) {
      st.set(i, cnt[a[i] ^ x]);
      cnt[a[i]] = i;
   }

   for (int i = 0; i < m; i++) {
      int l, r;
      cin >> l >> r;
      if (st.querry(l, r) <= r)
         cout << "yes\n";
      else
         cout << "no\n";
   }

   return 0;
}
{% endhighlight %}

## E - çˆ¬æ ‘çš„ç”²å£³è™«

æˆ‘ä»¬åªéœ€è¦è®¡ç®—æˆåŠŸçš„æ—¶é—´å³å¯ã€‚

é¦–å…ˆæˆ‘ä»¬æœ‰ $\frac{y-x}{y}$ çš„æ¦‚ç‡æˆåŠŸï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å¾—åˆ°å¼å­ $\frac{y-x}{y}E(i) = E(i - 1) + 1$

é‚£ä¹ˆç”±æ­¤æ¨å¾—å¼å­ $E(i) = \frac{y}{y-x}(E(i - 1) + 1)$

é€’æ¨æ±‚è§£å³å¯ã€‚

{% highlight cpp liones %}
#include <iostream>

using namespace std;

const int MOD = 998244353;
long long E[100010];

long long Q_power(long long a, long long b = MOD - 2) {
   long long res = 1;
   while (b) {
      if (b & 1) res = res * a % MOD;
      a = a * a % MOD;
      b >>= 1;
   }
   return res;
}

int main() {
   int n;
   scanf("%d", &n);

   for (int i = 1; i <= n; i++) {
      int x, y;
      scanf("%d%d", &x, &y);
      E[i] = (E[i - 1] + 1) * y % MOD * Q_power(y - x) % MOD;
   }

   cout << E[n] << '\n';

   return 0;
}
{% endhighlight %}

## F - é’è›™è¿‡æ²³

è¿™ä¸ªé¢˜ç›®ç¨å¾®ä½¿ç”¨äº†é¢˜ç›®ä¸Šçš„éšœçœ¼æ³•ã€‚

é¦–å…ˆå»å’Œå›æ˜¯ä¸€æ ·çš„ï¼Œä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬å¯ä»¥çœ‹æˆ $2x$ æ¬¡ä»å·¦åˆ°å³ã€‚

å†ç„¶åï¼Œæ¯ä¸ªçŸ³å­å¯ä»¥è·³è·ƒå›ºå®šæ¬¡æ•°ï¼Œæˆ‘ä»¬ä¸å¦¨çœ‹ä½œ $h_i$ ä¸ªåˆ†å¼€äº†çš„çŸ³å¤´ï¼Œç„¶åæˆ‘ä»¬å°±å¯ä»¥å‡è®¾æœ‰ $2x$ åªé’è›™ä»å·¦å¾€å³è·³ã€‚

é‚£ä¹ˆæœ€åï¼Œæˆ‘ä»¬äºŒåˆ†ç­”æ¡ˆï¼Œç„¶åä¾ç…§è´ªå¿ƒçš„æƒ³æ³•ï¼Œæ¯æ¬¡åœ¨è„šåŠ›çš„èŒƒå›´å†…å°½å¯èƒ½çš„è·³åˆ°å‰é¢ï¼Œé‚£ä¹ˆå¼€ä¸€ä¸ªé˜Ÿåˆ—ç»´æŠ¤å³å¯ã€‚

{% highlight cpp liones %}
#include <cstring>
#include <iostream>
using namespace std;

long long h[100010];
long long now[100010];
int q[100010];

int n, x;
bool check(int k) {
   for (int i = 1; i <= n; i++) now[i] = 0;
   q[0] = 0;
   now[0] = 2 * x;
   for (int head = 0, tail = 0, i = 1; i <= n; i++) {
      if (h[i] == 0) continue;
      if (q[head] < i - k) return false;
      q[++tail] = i;
      while (q[head] < q[tail]) {
         if (now[q[head]] + now[q[tail]] <= h[q[tail]]) {
            now[q[tail]] += now[q[head]];
            head++;
         } else {
            now[q[head]] -= h[q[tail]] - now[q[tail]];
            now[q[tail]] = h[q[tail]];
            break;
         }
      }
   }
   return now[n] >= 2 * x;
}

int main() {
   cin >> n >> x;
   for (int i = 1; i < n; i++) scanf("%lld", &h[i]);
   h[0] = h[n] = 100000000000ll;
   int l = 1, r = n;
   int res = r;

   while (l <= r) {
      int mid = (l + r) >> 1;
      if (check(mid)) {
         r = mid - 1;
         res = mid;
      } else {
         l = mid + 1;
      }
   }

   cout << res << '\n';

   return 0;
}
{% endhighlight %}



## G - æœ€é•¿ä¸ä¸‹é™å­åºåˆ—

é¦–å…ˆå…³äºæœ€é•¿ä¸é™å­åºåˆ—é¢˜ç›®ä¸­ï¼Œæˆ‘ä»¬é€šå¸¸åšæ³•æ˜¯å¼€ä¸€ä¸ªæ ˆç»´æŠ¤ã€‚é‚£ä¹ˆæ ¹æ®è¿™ä¸ªæ¨¡å¼æˆ‘ä»¬å°±å¯ä»¥å¾—åˆ°ä¸¤ä¸ªæ•°ã€‚

`pre[i]` è¡¨ç¤ºä»¥ `a[i]` ç»“å°¾æœ€å¤§ä¸é™å­åºåˆ—çš„é•¿åº¦ã€‚

`suf[i]` è¡¨ç¤ºä»¥ `a[i]` å¼€å§‹æœ€å¤§ä¸é™å­åºåˆ—çš„é•¿åº¦ã€‚

é‚£ä¹ˆæˆ‘ä»¬è€ƒè™‘è¿™ä¸ªé¢˜ç›®è¯¥æ€ä¹ˆåšã€‚

é¦–å…ˆé¢˜ç›®æœ‰ä¸ªåŸºç¡€æ¡†æ¶

~~~
pre | k | suf
~~~

å¯¹äº `pre` æ±‚ç»“å°¾å°äºç­‰äº `value --- k` çš„æœ€é•¿ä¸é™å­åºåˆ—ã€‚
å¯¹äº `suf` æ±‚ç»“å°¾å¤§äºç­‰äº `value --- k` çš„æœ€é•¿ä¸é™å­åºåˆ—ã€‚

é‚£ä¹ˆæˆ‘ä»¬å¯ä»¥è´ªå¿ƒçš„è€ƒè™‘ `k` ä¸å¦¨å°†æ•°åˆ—æ°å¥½åˆ†ä¸ºä¸‹é¢å‡ æ®µã€‚

~~~
[... i] [i + 1 , i + 2 , ... i + k] [i + k + 1... n]
~~~

æˆ‘ä»¬ç›´æ¥ä»¤ç»“å°¾ä¸º `a[i]` ç„¶åå¾€åé•¿åº¦ä¸º `k` çš„åºåˆ—éƒ½ä¸º `a[i]` ,ç„¶åæ±‚åœ¨ `[i + k + 1 ... n]` ä¸­å¼€å¤´å¤§äºç­‰äº `a[i]` çš„æ‰€æœ‰ä¸é™å­åºåˆ—ä¸­çš„æœ€å¤§é•¿åº¦å³å¯ã€‚

ç”±äºåªæ˜¯ç»´æŠ¤åŒºé—´æœ€å¤§å€¼ï¼Œç”¨æƒå€¼çº¿æ®µæ ‘ / æ ‘çŠ¶æ•°ç»„ç»´æŠ¤å³å¯ã€‚

é‚£ä¹ˆæœ€ç»ˆç­”æ¡ˆå°±æ˜¯ `pre[i] + k + max_range_upseq(a[i] ... max_a)`

{% highlight cpp liones %}
#include <algorithm>
#include <iostream>
#include <vector>

using namespace std;

const int N = 1e5 + 10;
const int M = 1e6 + 10;
int suf[N];
int pre[N];
int a[N];

vector<int> sufstk;
vector<int> prestk;

struct SEG_Tree {
   vector<int> mx;
   vector<pair<int, int>> Range;
   SEG_Tree() {
      int sz = 1;
      while (sz < M) sz *= 2;
      sz *= 2;
      mx.assign(sz, 0);
      Range.assign(sz, make_pair(0, 0));
      build(1, M);
   }

   int Lson(int x) { return x * 2 + 1; }
   int Rson(int x) { return x * 2 + 2; }

   void build(int l, int r, int p = 0) {
      Range[p].first = l, Range[p].second = r;
      if (l == r) return;
      int m = (l + r) / 2;
      build(l, m, Lson(p));
      build(m + 1, r, Rson(p));
   }

   void set(int x, int val, int p = 0) {
      int l = Range[p].first, r = Range[p].second;
      if (l == x && r == x) {
         mx[p] = val;
         return;
      }
      int m = (l + r) >> 1;
      if (m <= l) set(x, val, Lson(p));
      if (m > r) set(x, val, Rson(p));
      mx[p] = max(mx[Lson(p)], mx[Rson(p)]);
   }

   int querry(int x, int p = 0) {
      int l = Range[p].first, r = Range[p].second;
      if (x <= l || (l == r)) {
         return mx[p];
      }
      int m = (l + r) >> 1;
      int res = querry(x, Rson(p));
      if (x <= m) res = max(res, querry(x, Lson(p)));
      return res;
   }
};

int main() {
   int n, k;
   scanf("%d%d", &n, &k);
   for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
   for (int i = 1; i <= n; i++) {
      auto pos = upper_bound(prestk.begin(), prestk.end(), a[i]);
      if (pos == prestk.end()) {
         prestk.push_back(a[i]);
         pre[i] = prestk.size();
      } else {
         *pos = a[i];
         pre[i] = pos - prestk.begin() + 1;
      }
   }

   for (int i = n; i >= 1; i--) {
      auto pos = upper_bound(sufstk.begin(), sufstk.end(), a[i], less<int>());
      if (pos == sufstk.end()) {
         sufstk.push_back(a[i]);
         suf[i] = sufstk.size();
      } else {
         *pos = a[i];
         suf[i] = pos - sufstk.begin() + 1;
      }
   }

   int ans = k;

   SEG_Tree st;

   for (int i = n - k; i >= 0; i--) {
      ans = max(ans, pre[i] + k + st.querry(a[i]));
      st.set(a[i + k], suf[i + k]);
   }

   cout << ans << '\n';

   return 0;
}
{% endhighlight %}



## H - æ‰«ææ¸¸æˆ

ç»™ä¸ªæ€è·¯ ~~ ï¼Œå®ç°~~æ¯”è¾ƒå®¹æ˜“~~å°±ä¸å†™å•¦ã€‚

é¦–å…ˆæŒ‰ç…§æè§’åºæ’åºæ˜¯å…ä¸äº†çš„å•¦ã€‚

è‡³äºæ’åºå‘¢ï¼Œæˆ‘ä»¬ä»¥ä¸‹ä¸‰ä¸ªçº§åˆ«çš„å…³é”®è¯ã€‚
- è±¡é™
- å‰ç§¯
- z å€¼

è¿™ä¸ªæ¯”è¾ƒå®¹æ˜“å®ç°ã€‚

æ’å®Œåºä¹‹åæˆ‘ä»¬å°±å¾—åˆ°äº†ä¸€ä¸ªæ•°ç»„ï¼Œ`a[1 ... n]`ï¼Œè¿™æ˜¯ä¸€ä¸ªç¯ï¼Œæ‰€ä»¥æˆ‘ä»¬åœ¨å°¾å·´ä¸Šæ‹·è´ä¸€ä»½å¾—åˆ° `a[1 ... 2n]`ï¼Œæ¯æ¬¡æˆ‘ä»¬åªç”¨é•¿ä¸º `n` çš„éƒ¨åˆ†å°±å¥½ã€‚

ç„¶åæˆ‘ä»¬åœ¨è¿™ä¸ªä¸Šé¢å¼€ä¸€ä¸ªçº¿æ®µæ ‘ï¼Œç„¶åæˆ‘ä»¬å¼€ä¸€ä¸ª `std::set`, `std::set`ä¸­çš„æ’åºå…³é”®å­—ä¸º z å€¼ã€‚

é‚£ä¹ˆç°åœ¨å¼€å§‹æˆ‘ä»¬éœ€è¦ç»´æŠ¤ä¸¤ä¸ªå€¼ ï¼Œæ£’å­çš„é«˜åº¦ `h`ï¼Œå’Œå½“å‰çš„ä½ç½®`now`ï¼ˆä¸ºäº†æ–¹ä¾¿æˆ‘ä»¬å¯ä»¥åœ¨ a[0] å¤„åŠ å…¥ä¸€ä¸ªç‚¹ `(0 , h) , z = 0`ï¼‰ã€‚

è¿™ä¸ªé«˜åº¦å»ºè®®å¤§å®¶ç”¨å¹³æ–¹åçš„å€¼æ¥è¡¨ç¤ºé¿å…ç²¾åº¦æŸå¤±é—®é¢˜ã€‚

é‚£ä¹ˆæˆ‘ä»¬æœ€å¤šè¿›è¡Œ `n` å¦‚ä¸‹æ­¥éª¤çš„å¾ªç¯ã€‚

1. å°† `std::set` ä¸­æ‰€æœ‰å°äºå½“å‰çš„é«˜åº¦çš„å€¼åŠ å…¥åˆ°çº¿æ®µæ ‘ä¸­(è®°å¾—æœ‰ä¸¤ä»½ `i` å’Œ `i + n`)ã€‚

   ```cpp
   while(s.size() && *set.begin().z <= h) {
      auto [pos , z] = *set.begin();
      st.set(pos , pos) , st.set(pos + n , pos + n);
      s.erase(s.begin());
   }
   ```

2. æ‰¾åˆ°ä¸‹ä¸€ä¸ªåº”è¯¥æ‰¾çš„å€¼,å¹¶å°†è¯¥ä½ç½®ä¸Šçš„å€¼ç½®ä¸º `+inf` ã€‚å¦‚æœæ²¡æ‰¾åˆ°åˆ™ç»“æŸã€‚
   ```cpp
   int nxt = st.min(now , now + n);
   if(nxt > 2 * n) break;
   now = nxt % n;
   if(now == 0) now = n;
   st.set(now , +INF) , st.set(now + n , +INF);
   ```

   å†™åˆ°è¿™é‡Œï¼Œæˆ‘ä»¬å‘ç°æˆ‘ä»¬è¿˜ç¼ºå°‘å‡ ä¸ªå€¼ï¼Œ
   - æ–¹å‘ --> æˆ‘æ‰“ç®—ç”¨å‘é‡è¡¨ç¤º `(x , y)` 
   - è¯¥å¡«çš„å€¼ --> è¿™ä¸ªç”¨ `now_value`

   é‚£ä¹ˆæˆ‘ä»¬åœ¨ä¸Šé¢çš„ç­”æ¡ˆåŠ ä¸Šä¸‹é¢çš„è¯­å¥å°±å¯ä»¥äº†ã€‚

   ```cpp
   auto [xx , yy] = a[now];
   int g = __gcd(abs(x) , abs(y));
   xx /= g , yy /= g;
   if(xx == x && yy == y) ans[now] = now_value;
   else ans[now] = ++now_value;
   ```

é‚£ä¹ˆåˆ°è¿™ä¹Ÿå°±ç»“æŸäº†ï¼Œæˆ‘æ„Ÿè§‰è¿™åº”è¯¥æ˜¯è¿™å¼ è€ƒå·ä¸Šæœ€éš¾çš„é¢˜äº†å§ã€‚

è¿˜å‰©ä¸‹äº†çš„è¾¹ç•Œæ¡ä»¶ï¼Œå¤§å®¶è¯·è‡ªå·±æ¢ç´¢ï¼Œä¾‹å¦‚æºç‚¹æœ‰ç‚¹ï¼Œé‚£ä¹ˆæˆ‘ä¸Šé¢æä¾›çš„çš„å¤„ç†æ–¹æ¡ˆå°±ä¸è¡Œäº†ï¼Œéœ€è¦ç‰¹åˆ¤ã€‚

[SUCCESSğŸ‰](#2i---æ•°çš„æ‹†åˆ†){:.button.button--outline-secondary.button--pill}

æœ‰ä»€ä¹ˆä¸æ‡‚çš„æ¬¢è¿åœ¨è¯„è®ºç•™è¨€å¥¥ ğŸ¤—



## I - æ•°çš„æ‹†åˆ†

è¿™ä¸ªæ•°å‘¢æˆ‘ä»¬åˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ†ã€‚

é¦–å…ˆæ˜¯è¿™ä¸ªæ•°å­—æ˜¯ $x^y$ çš„å½¢å¼ã€‚

ç„¶åæ˜¯ $x_1^{y_1}\cdot x_2^{y_2}$ çš„å½¢å¼ã€‚

æˆ‘ä»¬å¾ˆå®¹æ˜“å‘ç°ä¸€ç‚¹ $x_1^2\cdot x_2^2=(x_1x_2)^2$ é‚£ä¹ˆçš„è¯ï¼Œé‚£ä¹ˆæˆ‘ä»¬ç¬¬äºŒç§å½¢å¼æœ€å®¹æ˜“æƒ³åˆ°çš„æ˜¯ $x_1^2x_2^3$

è¿™ä¸ªæ—¶å€™æˆ‘ä»¬å‘ç°ï¼Œå¦‚æœæˆ‘ä»¬è¦æŠŠ $10^{18}$ æ‹†æˆä¸¤ä¸ªæ•°å­—çš„è¯ã€‚ä¸‹é¢çš„å¾ªç¯ä¸€å®šä¸ä¼šè¶…è¿‡ `1000`ã€‚æˆ‘ä»¬æ­¤æ—¶å†åšä¸€ä¸ªè´¨å› ç´ åˆ†è§£ï¼Œé‚£ä¹ˆæˆ‘ä»¬çš„å¾ªç¯æœ€å¤šä¸ä¼šè¶…è¿‡ `200` ã€‚

{% highlight cpp liones %}
for (int i = 1 ; i <= limit ; i ++ ) {
    if(a % prime[i] == 0) break;
}
{% endhighlight %}

é‚£ä¹ˆæœ€åæˆ‘ä»¬å¯ä»¥æœ‰ä»¥ä¸‹çš„æ­¥éª¤äº†ã€‚

> ä¼¼ä¹ `1000` è¿˜ä¸å¤Ÿï¼Œæƒ¨å¤±ğŸ’€ éœ€è¦ `4000` ï¼Œ ä»¥ä¸‹å‡ä¿®æ”¹ä¸º `4000` 

1. æ‹†å‡ºæ¥ä¸€ä¸ª `<= 4000` çš„ç´ å› å­ã€‚å¾—åˆ° `cnt` (æœ€å¤šä¸è¶…è¿‡ $256$ æ¬¡è®¡ç®—)ã€‚
2. åˆ¤æ–­æ˜¯å¦æˆå¹‚æ•°ã€‚($O(\log \sqrt n)\approx 32$)

ç»™ä¸ªæµç¨‹å›¾

ç”±äº 1 ä¹Ÿæ˜¯å®Œå…¨å¹‚æ•°ã€‚

~~~mermaid
flowchart LR;
	a[step1] --->|æ‹†å‡ºæ¥ cnt >= 2|b[step2] --->|æˆåŠŸ| c[è¾“å‡ºyes]
	a --->|æ‹†å‡ºæ¥ cnt == 1|d[è¾“å‡ºno]
	a --->|æ‹†å‡ºæ¥ cnt == 0|b
	
~~~

{% highlight cpp liones %}
#include <iostream>
#include <vector>
using namespace std;

vector<int> prime;

long long nu[] = {2, 3, 5, 7};
long long rg[] = {1000000000ll, 1000000ll, 3982ll, 373ll};

bool is_prime(int x) {
   for (int i = 2; i * i <= x; i++) {
      if (x % i == 0) return false;
   }
   return true;
}

void init() {
   for (int i = 2; i <= 4000; i++)
      if (is_prime(i)) prime.push_back(i);
}

long long qpow(long long a, long long b) {
   long long res = 1;
   while (b) {
      if (b & 1) {
         res = res * a;
      }
      b >>= 1;
      a = a * a;
   }
   return res;
}

bool check(long long a, int times) {
   long long l = 1, r = rg[times];
   while (l <= r) {
      long long mid = (l + r) >> 1;
      long long val = qpow(mid, nu[times]);
      if (val == a) return true;
      if (val > a) r = mid - 1;
      if (val < a) l = mid + 1;
   }
   return false;
}

void solve() {
   long long a;
   scanf("%lld", &a);

   int cnt = 0;
   for (auto pri : prime) {
      if (a % pri == 0) {
         while (a % pri == 0) {
            a /= pri;
            cnt++;
         }
         break;
      }
   }

   if (cnt == 1) {
      puts("no");
      return;
   }

   for (int i = 0; i < 4; i++)
      if (check(a, i)) {
         puts("yes");
         return;
      }
   puts("no");
}

int main() {
   int t;
   cin >> t;
   init();
   while (t--) solve();
}
{% endhighlight %}

## J - æ¨å¯¼éƒ¨åˆ†å’Œ

ç®€å•ç‰ˆçš„é¢˜ç›®å¯è§

[è¯¦æƒ…å¯è§]({% link _posts/2022-01-03M/2022-02-20-Range-sums.md %}){:.button.button--secondary.button--pill}

è¿™ä¸ªé¢˜ç›®å¦‚æœåŒ–ä¸ºå‰ç¼€å’Œçš„å½¢å¼æ¥çœ‹å¯ä»¥å˜ä¸º

`S[r] - S[l - 1] = k -->  S[r] = S[l - 1] + k`

é‚£ä¹ˆæœ‰è¿™ä¸ªå…³ç³»æˆ‘ä»¬å»ºç«‹å›¾ / æˆ–å¸¦æƒå¹¶æŸ¥é›†å³å¯ã€‚

æˆ‘çš„ä»£ç æ˜¯ç”¨å¹¶æŸ¥é›†å†™çš„ã€‚

> æˆ‘å‘ç°æˆ‘äº¤çš„æ˜¯ `UNKNOW` ,ç­”æ¡ˆæ˜¯ `UNKNOWN`. è¿™èµ›åˆ¶ã€‚ã€‚ã€‚

{% highlight cpp liones %}
#include <cassert>
#include <iostream>

using namespace std;

const int N = 1e5 + 10;

int fa[N];
long long vue[N];

int find(int x) {
   if (fa[x] == x) return x;
   int f = fa[x];
   int ff = find(fa[x]);
   vue[x] += vue[f];
   return fa[x] = ff;
}

void merge(int l, int r, long long v) {
   l--;
   if (find(l) == find(r)) return;
   if (find(l) < find(r)) {
      int ff = find(r);
      vue[ff] = v - vue[r];
      fa[ff] = l;
   } else {
      v = -v;
      int ff = find(l);
      vue[ff] = v - vue[l];
      fa[ff] = r;
   }
}

int main() {
   int n, m, q;
   scanf("%d%d%d", &n, &m, &q);
   for (int i = 0; i <= n; i++) fa[i] = i;
   for (int i = 0; i < m; i++) {
      int l, r;
      long long v;
      scanf("%d%d%lld", &l, &r, &v);
      merge(l, r, v);
   }
   while (q--) {
      int l, r;
      scanf("%d%d", &l, &r);
      if (find(l - 1) == find(r)) {
         printf("%lld\n", vue[r] - vue[l - 1]);
      } else
         puts("UNKNOWN");
   }
}
{% endhighlight %}


æœ‰ä»€ä¹ˆé—®é¢˜æ¬¢è¿ç•™è¨€ ğŸ˜˜



 

